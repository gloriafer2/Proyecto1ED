/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package Interfaces;
import EDD.Grafo;
import Interfaces.Cargar;


/**
 *
 * @author Gloria
 */
public class BuscarPalabra extends javax.swing.JFrame {
    public  Grafo grafo;
    private String[] diccionario;
    private char[][] tablero;
    private Cargar ventanaCargarOriginal;

    /**
     * Creates new form BuscarPalabra
     */
    public BuscarPalabra(Grafo g, String[] dict, char[][] tab, Cargar v1) {
        initComponents();
        this.grafo = g;
        this.diccionario = dict;
        this.tablero = tab;
        this.ventanaCargarOriginal = v1;
        this.setLocationRelativeTo(null);
        this.setResizable(false);
    }
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        JLabelTitulo = new javax.swing.JLabel();
        jScrollPaneResultados = new javax.swing.JScrollPane();
        textAreaResultados = new javax.swing.JTextArea();
        jLabelTiempo = new javax.swing.JLabel();
        botonRegresar = new javax.swing.JButton();
        jButton1 = new javax.swing.JButton();
        jButton2 = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jPanel1.setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        JLabelTitulo.setFont(new java.awt.Font("Arial", 0, 24)); // NOI18N
        JLabelTitulo.setText("Palabras Encontradas");

        textAreaResultados.setEditable(false);
        textAreaResultados.setColumns(20);
        textAreaResultados.setRows(5);
        jScrollPaneResultados.setViewportView(textAreaResultados);

        jLabelTiempo.setText("Tiempo de busqueda");

        botonRegresar.setText("Regresar");
        botonRegresar.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonRegresarActionPerformed(evt);
            }
        });

        jButton1.setText("jButton1");

        jButton2.setText("jButton2");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap(54, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18)
                        .addComponent(jButton1)
                        .addGap(111, 111, 111)
                        .addComponent(jButton2)
                        .addGap(67, 67, 67))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jScrollPaneResultados, javax.swing.GroupLayout.PREFERRED_SIZE, 291, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(botonRegresar)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jLabelTiempo, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(28, 28, 28))
            .addGroup(layout.createSequentialGroup()
                .addGap(80, 80, 80)
                .addComponent(JLabelTitulo)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(JLabelTitulo)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(16, 16, 16)
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(jButton1)
                            .addComponent(jButton2))))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPaneResultados, javax.swing.GroupLayout.PREFERRED_SIZE, 172, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelTiempo)
                    .addComponent(botonRegresar))
                .addContainerGap(18, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void botonRegresarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonRegresarActionPerformed
        // TODO add your handling code here:
        this.setVisible(false);
    Menu menuNuevo = new Menu(this.ventanaCargarOriginal);
    menuNuevo.setVisible(true);
    this.dispose();
    }//GEN-LAST:event_botonRegresarActionPerformed
    private void iniciarBusquedaDeTodasLasPalabras() {
        System.out.println("DEBUG (BuscarPalabra): Iniciando búsqueda de todas las palabras.");

        // Verificación de que los datos necesarios no sean nulos o vacíos.
        if (this.grafo == null || this.diccionario == null || this.tablero == null || this.diccionario.length == 0) {
            String errorMsg = "ERROR (BuscarPalabra): Datos incompletos para iniciar la búsqueda.";
            System.err.println(errorMsg); // Para depuración
            textAreaResultados.setText(errorMsg + "\nPor favor, asegúrate de cargar el archivo correctamente desde el menú principal.");
            jLabelTiempo.setText("Tiempo de búsqueda: Error de datos");
            return;
        }

        long startTime = System.currentTimeMillis(); // Captura el tiempo de inicio de la búsqueda.

        StringBuilder resultadosBuilder = new StringBuilder(); // Se usa para construir el texto de resultados sin java.util.List
        int palabrasEncontradasCount = 0; // Contador de palabras encontradas.

        // Itera sobre cada palabra presente en el diccionario.
        for (int i = 0; i < diccionario.length; i++) {
            String palabra = diccionario[i];
            // Omite palabras nulas, vacías o que solo contengan espacios.
            if (palabra == null || palabra.trim().isEmpty()) {
                continue;
            }
            palabra = palabra.trim().toUpperCase(); // Normaliza la palabra (sin espacios, mayúsculas).

            // Requisito del proyecto: Una palabra válida debe tener al menos 3 letras.
            if (palabra.length() < 3) {
                System.out.println("DEBUG (BuscarPalabra): Palabra '" + palabra + "' ignorada, menos de 3 letras.");
                continue; // Salta a la siguiente palabra del diccionario.
            }

            System.out.println("DEBUG (BuscarPalabra): Buscando palabra: " + palabra);

            boolean foundInBoard = false; // Bandera para saber si la palabra ya fue encontrada en el tablero.
            // Para cada palabra, se intenta encontrarla comenzando desde cada celda del tablero (4x4).
            for (int r = 0; r < 4; r++) { // Bucle para filas (0 a 3)
                for (int c = 0; c < 4; c++) { // Bucle para columnas (0 a 3)
                    // Se crea una nueva matriz 'visited' para cada intento de búsqueda de la palabra
                    // desde una celda inicial diferente, asegurando que cada búsqueda sea independiente.
                    boolean[][] visited = new boolean[4][4];
                    // Llama a la función recursiva de búsqueda (DFS).
                    if (buscarPalabraEnCelda(palabra, r, c, visited, 0)) { // 0 es el índice de la primera letra de la palabra.
                        palabrasEncontradasCount++; // Incrementa el contador de palabras encontradas.
                        resultadosBuilder.append("- ").append(palabra).append("\n"); // Añade la palabra al StringBuilder.
                        System.out.println("DEBUG (BuscarPalabra): Palabra encontrada: " + palabra);
                        foundInBoard = true; // Marca que la palabra fue encontrada.
                        break; // Sale del bucle de columnas, ya que la palabra se encontró.
                    }
                }
                if (foundInBoard) {
                    break; // Sale del bucle de filas, ya que la palabra se encontró.
                }
            }
        }

        long endTime = System.currentTimeMillis(); // Captura el tiempo de finalización.
        long duration = endTime - startTime; // Calcula la duración total en milisegundos.

        // Muestra los resultados y el tiempo en el JTextArea y JLabel correspondientes.
        if (palabrasEncontradasCount == 0) {
            textAreaResultados.setText("No se encontraron palabras del diccionario en la sopa de letras.");
        } else {
            textAreaResultados.setText("Palabras encontradas (" + palabrasEncontradasCount + "):\n" + resultadosBuilder.toString());
        }
        jLabelTiempo.setText("Tiempo de búsqueda: " + duration + " ms"); // Actualiza el JLabel del tiempo.

        System.out.println("DEBUG (BuscarPalabra): Resultados finales:\n" + textAreaResultados.getText());
        System.out.println("DEBUG (BuscarPalabra): Tiempo total de búsqueda: " + duration + " ms");
    }

    /**
     * Implementa el algoritmo de búsqueda DFS (Depth First Search) o backtracking
     * para encontrar una secuencia de letras que formen una palabra en el tablero.
     * Se mueve recursivamente a celdas adyacentes hasta encontrar la palabra completa.
     *
     * @param palabra La palabra (en mayúsculas) que se está buscando.
     * @param currentRow Fila actual en la que se encuentra la búsqueda.
     * @param currentCol Columna actual en la que se encuentra la búsqueda.
     * @param visited Matriz booleana para marcar las celdas ya visitadas en la ruta actual de la palabra.
     * Esto evita ciclos y el uso repetido de la misma letra para la misma palabra.
     * @param charIndex El índice de la letra actual que se busca en la 'palabra' (ej. 0 para la primera letra).
     * @return true si la 'palabra' se encuentra a partir de la celda (currentRow, currentCol), false en caso contrario.
     */
    private boolean buscarPalabraEnCelda(String palabra, int currentRow, int currentCol, boolean[][] visited, int charIndex) {
        // Caso base 1: Si charIndex es igual a la longitud de la palabra, significa que todas las letras
        // de la palabra han sido encontradas en secuencia válida.
        if (charIndex == palabra.length()) {
            return true;
        }

        // Caso base 2: Condiciones para detener la búsqueda en la ruta actual:
        // 1. Si las coordenadas (currentRow, currentCol) están fuera de los límites del tablero (4x4).
        // 2. Si la celda actual ya ha sido visitada en esta ruta de búsqueda (evita usar la misma letra dos veces).
        // 3. Si la letra en la celda actual del tablero no coincide con la letra esperada de la palabra.
        //    (Se convierte a mayúsculas para asegurar una comparación sin distinción entre mayúsculas y minúsculas).
        if (currentRow < 0 || currentRow >= 4 || currentCol < 0 || currentCol >= 4 ||
            visited[currentRow][currentCol] || Character.toUpperCase(tablero[currentRow][currentCol]) != palabra.charAt(charIndex)) {
            return false;
        }

        // Marcar la celda actual como visitada para la ruta de búsqueda actual.
        visited[currentRow][currentCol] = true;

        // Convierte las coordenadas (fila, columna) de la celda actual a un índice de vértice del grafo (0-15).
        int currentVertex = currentRow * 4 + currentCol;

        // Itera sobre todos los posibles vértices (de 0 a 15) para encontrar sus adyacencias en el grafo.
        // Esto cubre todas las 8 direcciones posibles (horizontal, vertical, diagonal) si el grafo
        // fue construido para representarlas.
        for (int neighborVertex = 0; neighborVertex < 16; neighborVertex++) {
            // Verifica si el 'neighborVertex' es adyacente al 'currentVertex' en el grafo.
            // USANDO EL MÉTODO EXISTENTE EN TU CLASE GRAFO: grafo.existeArista()
            if (grafo.existeArista(currentVertex, neighborVertex)) {
                // Convierte el índice del vértice vecino de nuevo a coordenadas de fila y columna.
                int nextRow = neighborVertex / 4;
                int nextCol = neighborVertex % 4;

                // Realiza una llamada recursiva para buscar la siguiente letra de la palabra
                // en la celda del vecino. Se incrementa el charIndex para buscar la siguiente letra.
                if (buscarPalabraEnCelda(palabra, nextRow, nextCol, visited, charIndex + 1)) {
                    return true; // Si la llamada recursiva encuentra el resto de la palabra, retorna true.
                }
            }
        }
    System.out.println("DEBUG (BuscarPalabra-Constructor): Grafo recibido es null? " + (this.grafo == null));
System.out.println("DEBUG (BuscarPalabra-Constructor): Diccionario recibido es null? " + (this.diccionario == null));
System.out.println("DEBUG (BuscarPalabra-Constructor): Tablero recibido es null? " + (this.tablero == null));
if (this.diccionario != null && this.diccionario.length > 0) {
    System.out.println("DEBUG (BuscarPalabra-Constructor): Cantidad de palabras en diccionario: " + this.diccionario.length);
    System.out.println("DEBUG (BuscarPalabra-Constructor): Primer palabra del diccionario: " + this.diccionario[0]);
}
if (this.tablero != null && this.tablero.length == 4 && this.tablero[0].length == 4) {
    System.out.println("DEBUG (BuscarPalabra-Constructor): Letra en (0,0): " + this.tablero[0][0]);
    // Puedes imprimir el tablero completo si quieres verificar:
    System.out.println("DEBUG (BuscarPalabra-Constructor): Contenido del tablero:");
    for (int r = 0; r < 4; r++) {
        for (int c = 0; c < 4; c++) {
            System.out.print(this.tablero[r][c] + " ");
        }
        System.out.println();
    }

        // Backtrack: Si la búsqueda a través de todas las celdas adyacentes no encontró la palabra,
        // desmarca la celda actual como visitada. Esto es fundamental para que otras rutas de búsqueda
        // (que quizás comiencen en una celda diferente) puedan usar esta celda.
        visited[currentRow][currentCol] = false;
        return false; // La palabra no se encontró a partir de esta celda y esta ruta.
        
    }

    /**
     * Manejador de eventos para el botón "Regresar al Menú".
     * Oculta la ventana actual de búsqueda y crea y muestra una nueva instancia del menú principal.
     * @param evt El evento de acción.
     */
   
    
    

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel JLabelTitulo;
    private javax.swing.JButton botonRegresar;
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JLabel jLabelTiempo;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JScrollPane jScrollPaneResultados;
    private javax.swing.JTextArea textAreaResultados;
    // End of variables declaration//GEN-END:variables
}
